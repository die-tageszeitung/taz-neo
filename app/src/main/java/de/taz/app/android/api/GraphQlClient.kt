package de.taz.app.android.api

import android.content.Context
import androidx.annotation.VisibleForTesting
import com.squareup.moshi.JsonEncodingException
import de.taz.app.android.BuildConfig
import de.taz.app.android.MAX_SIMULTANIOUS_QUERIES
import de.taz.app.android.TAZ_AUTH_HEADER
import de.taz.app.android.annotation.Mockable
import de.taz.app.android.api.dto.DataDto
import de.taz.app.android.api.dto.WrapperDto
import de.taz.app.android.api.models.AuthStatus
import de.taz.app.android.api.variables.Variables
import de.taz.app.android.singletons.AuthHelper
import de.taz.app.android.singletons.JsonHelper
import de.taz.app.android.util.SingletonHolder
import de.taz.app.android.util.reportAndRethrowExceptions
import io.ktor.client.*
import io.ktor.client.engine.android.*
import io.ktor.client.request.*
import io.sentry.Sentry
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.sync.Semaphore
import kotlinx.coroutines.sync.withPermit
import kotlinx.coroutines.withContext
import kotlin.Throws

/**
 * class to get DTOs from the [BuildConfig.GRAPHQL_ENDPOINT]
 */
@Mockable
class GraphQlClient @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE) constructor(
    private val httpClient: HttpClient = HttpClient(Android),
    private val url: String,
    private val queryService: QueryService,
    private val authHelper: AuthHelper
) {
    private constructor(applicationContext: Context) : this(
        url = BuildConfig.GRAPHQL_ENDPOINT,
        queryService = QueryService.getInstance(applicationContext),
        authHelper = AuthHelper.getInstance(applicationContext)
    )

    private val unrecoverableGraphQlErrorCategories = listOf("businessLogic", "graphql ")

    companion object : SingletonHolder<GraphQlClient, Context>(::GraphQlClient)

    private val maxSimultaneousRequestSemaphore = Semaphore(MAX_SIMULTANIOUS_QUERIES)

    /**
     * function to get DTO from query
     * @param queryType - the type of the query to execute
     * @param variables - the variables to set on query
     * @return the [DataDto] generated by parsing the returned json with moshi
     */
    @Throws(
        MalformedServerResponseException::class,
        GraphQlImplementationException::class,
        GraphQlRecoverableServerException::class
    )
    suspend fun query(queryType: QueryType, variables: Variables? = null): WrapperDto =
        withContext(Dispatchers.IO) {
            val query = queryService.get(queryType)
            variables?.let { query.variables = variables }

            val queryBody = query.toJson()

            val wrapper = try {
                val jsonText = maxSimultaneousRequestSemaphore.withPermit {
                    httpClient.post<String>(url) {
                        header("Accept", "application/json, */*")
                        header("Content-Type", "application/json")
                        body = queryBody
                        val token = authHelper.token
                        if (!token.isNullOrEmpty()
                            && (authHelper.isLoggedIn() || queryType == QueryType.Subscription)
                        ) {
                            header(TAZ_AUTH_HEADER, token)
                        }
                    }
                }
                JsonHelper.adapter<WrapperDto>().fromJson(jsonText)!!
            } catch (e: NullPointerException) {
                reportAndRethrowExceptions {
                    throw MalformedServerResponseException(e)
                }
            } catch (e: JsonEncodingException) {
                reportAndRethrowExceptions {
                    throw MalformedServerResponseException(e)
                }
            }

            if (wrapper.errors.isNotEmpty()) {
                if (wrapper.errors.findLast { item ->
                        unrecoverableGraphQlErrorCategories.contains(item.extensions?.category)
                    } != null) {
                    log.error("A faulty response from graphQL received ${wrapper.errors}")
                    throw GraphQlImplementationException(wrapper)
                } else {
                    throw GraphQlRecoverableServerException(wrapper)
                }
            }

            // if response carries authinfo we save it
            wrapper.data?.product?.authInfo?.let {
                // only update if it changes
                if (authHelper.authStatus != it.status) {
                    authHelper.authStatus = it.status
                }
            }
            wrapper
        }

    class MalformedServerResponseException(cause: Throwable? = null) :
        Exception("GraphQL server returned unexpected response", cause)

    class GraphQlImplementationException(wrapperDto: WrapperDto?) :
        Exception("An unrecoverable GraphQL exception occured: $wrapperDto")

    class GraphQlRecoverableServerException(wrapperDto: WrapperDto?) :
        Exception("A probably recoverable error occured: $wrapperDto")
}
