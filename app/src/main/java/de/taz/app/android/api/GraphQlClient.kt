package de.taz.app.android.api

import android.content.Context
import androidx.annotation.VisibleForTesting
import de.taz.app.android.BuildConfig
import de.taz.app.android.MAX_SIMULTANEOUS_QUERIES
import de.taz.app.android.TAZ_AUTH_HEADER
import de.taz.app.android.annotation.Mockable
import de.taz.app.android.api.dto.DataDto
import de.taz.app.android.api.dto.WrapperDto
import de.taz.app.android.api.variables.Variables
import de.taz.app.android.singletons.AuthHelper
import de.taz.app.android.util.SingletonHolder
import de.taz.app.android.util.reportAndRethrowExceptions
import io.ktor.client.*
import io.ktor.client.call.*
import io.ktor.client.engine.cio.*
import io.ktor.client.request.*
import io.ktor.http.*
import io.ktor.serialization.*
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.sync.Semaphore
import kotlinx.coroutines.sync.withPermit
import kotlinx.coroutines.withContext
import kotlinx.serialization.json.Json
import kotlinx.serialization.json.decodeFromStream

/**
 * class to get DTOs from the [BuildConfig.GRAPHQL_ENDPOINT]
 */
@Mockable
class GraphQlClient @VisibleForTesting(otherwise = VisibleForTesting.PRIVATE) constructor(
    private val httpClient: HttpClient = HttpClient(CIO),
    private val url: String,
    private val queryService: QueryService,
    private val authHelper: AuthHelper
) {
    private constructor(applicationContext: Context) : this(
        url = BuildConfig.GRAPHQL_ENDPOINT,
        queryService = QueryService.getInstance(applicationContext),
        authHelper = AuthHelper.getInstance(applicationContext)
    )

    private val unrecoverableGraphQlErrorCategories = listOf("businessLogic", "graphql ")

    companion object : SingletonHolder<GraphQlClient, Context>(::GraphQlClient)

    private val maxSimultaneousRequestSemaphore = Semaphore(MAX_SIMULTANEOUS_QUERIES)

    /**
     * function to get DTO from query
     * @param queryType - the type of the query to execute
     * @param variables - the variables to set on query
     * @return the [DataDto] generated by parsing the returned json
     */
    @Throws(
        MalformedServerResponseException::class,
        GraphQlImplementationException::class,
        GraphQlRecoverableServerException::class
    )
    suspend fun query(queryType: QueryType, variables: Variables? = null): WrapperDto =
        withContext(Dispatchers.IO) {
            val query = queryService.get(queryType)
            variables?.let { query.variables = variables }

            val queryBody = query.toJson()

            val wrapper = try {
                val response = maxSimultaneousRequestSemaphore.withPermit {
                    httpClient.post(Url(url)) {
                        accept(ContentType.Application.Json)
                        accept(ContentType.Any)
                        contentType(ContentType.Application.Json)
                        setBody(queryBody)
                        val token = authHelper.token.get()
                        if (token.isNotEmpty()
                            && (authHelper.isLoggedIn() || queryType == QueryType.Subscription)
                        ) {
                            header(TAZ_AUTH_HEADER, token)
                        }
                    }
                }
                Json.decodeFromStream<WrapperDto>(response.body())
            } catch (e: NullPointerException) {
                reportAndRethrowExceptions {
                    throw MalformedServerResponseException(e)
                }
            } catch (e: JsonConvertException) {
                reportAndRethrowExceptions {
                    throw MalformedServerResponseException(e)
                }
            }

            if (wrapper.errors.isNotEmpty()) {
                if (wrapper.errors.findLast { item ->
                        unrecoverableGraphQlErrorCategories.contains(item.extensions?.category)
                    } != null) {
                    log.error("A faulty response from graphQL received ${wrapper.errors}")
                    throw GraphQlImplementationException(wrapper)
                } else {
                    throw GraphQlRecoverableServerException(wrapper)
                }
            }

            // if response carries authinfo we save it
            wrapper.data?.product?.authInfo?.let {
                // only update if it changes
                if (authHelper.status.get() != it.status) {
                    authHelper.status.set(it.status)
                }
            }
            wrapper
        }

    class MalformedServerResponseException(cause: Throwable? = null) :
        Exception("GraphQL server returned unexpected response", cause)

    class GraphQlImplementationException(wrapperDto: WrapperDto?) :
        Exception("An unrecoverable GraphQL exception occured: $wrapperDto")

    class GraphQlRecoverableServerException(wrapperDto: WrapperDto?) :
        Exception("A probably recoverable error occured: $wrapperDto")
}
